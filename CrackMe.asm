.model tiny       
.286       
.code             
org 100h  
; 1) какую лучше постараться сделать увезвимость  -> подобрать хэш то есть два пароля дают один и тот же хэ
; 2) что можно сделать пока друг еще пишет прогу  

; узнать про флаг переполнения (перезапис стека, перезапис сегмента)
; таблетка 
; диссасм (добавь комментрарии, )
; написать readme

; перенаправление в другой файл 
;----------------------------------------------------------------------
;  коллизии хэша
;   1) gullo
;   2) 
;----------------------------------------------------------------------

; TODO https://backlect.gitbook.io/intro-rev-ida-pro/chast-03

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;  фрагмент кода который можно вставить во втором задании для перезаписывании сегмента и ввести 'dello' -> пройдет 
;                mov si, offset user_buffer
;                mov cx, 100 ; Пытаемся записать 100 байт
;                mov al, 'A'
;                rep stosb ; Заполняем память символом 'A' 
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;-------------------------------------------------------------------------------------------
; план что сделать
; 1) разобраться с дисасемблером (с начало IDA)
;    - написать Тохе, уточнить что конкретно нужно от дисасма(коменты и граф)
;    - написать Коле и уточнить где он искал инфу про IDA
; 2) написать там комментарии и построить графы 
; 3) придумать у все в проге две утечки пароля 
;    - коллизия хэша (написать прогу которая будет перебирать такие хэши) 
;    - сделать переполнение стека/сегмента (узнать про флаги переполнения)
; 4) сделать две или три проги (одна - без утечек, 2/3 - с утечками)
; 5) начать потихоньку писать readme 
; 6) разобраться с графикой для второго задания 
;-------------------------------------------------------------------------------------------
Start: 
                ; считываем хэш пароля
                mov  si, offset password 
                call elf_hash               ; функция которая считает хеш пароля 
                mov  true_hash, ax      

                ; выводим предложение вести пароль
                mov dx, offset invitation  
                mov ah, 09h
                int 21h

                ; считываем пароль
                mov  si, offset user_buffer
                call enter_password         

                ; вычисляем хэш введенного пароля 
                mov  si, offset user_buffer
                call elf_hash

                ; сравниваем хеши 
                cmp ax, true_hash
                jne fail_case

success_case:
                mov dx, offset success_msg
                mov ah, 09h
                int 21h
                jmp end_case

fail_case:
                mov dx, offset fail_msg
                mov ah, 09h
                int 21h

end_case:
                mov ax, 4c00h
                int 21h
;-----------------------------------------------------

;====================================================================
; Функция для ввода пароля 
;====================================================================
enter_password proc
               push bp
               mov  bp, sp
               xor  cx, cx

@@while1:
               mov ah, 01h ; 07h
               int 21h
               cmp al, 0dh
               je @@end_while

               mov [si],al
               inc  si
               inc  cx
               jmp @@while1

@@end_while:
               mov byte ptr [si], 0
               pop bp
               ret

enter_password endp

;====================================================================
; Функция для вычисления хэша (ElfHash)
;====================================================================
elf_hash       proc
               push bp
               mov  bp, sp
               xor  ax, ax                          ; Обнуляем ax (здесь будет храниться хэш)
               xor  bx, bx                          ; Обнуляем bx (временный регистр)

@@for_start: 
               mov bl, [si]                         ; Загружаем символ из буфера в bl
               cmp bl, 0                            ; Проверяем, достигнут ли конец строки
               je @@end_for                         ; Если да, завершаем цикл

               ; Алгоритм ELFHash
               shl ax, 4                            ; Сдвигаем хэш на 4 бита влево
               add ax, bx                           ; Добавляем ASCII-код символа к хэшу
               mov bx, ax                           ; Копируем хэш в bx
               and bx, 0F000h                       ; Выделяем старшие 4 бита
               shr bx, 12                           ; Сдвигаем их на 12 бит вправо
               xor ax, bx                           ; XOR с хэшем
               and ax, 0FFFFh                       ; Оставляем только младшие 16 бит

               inc si                               ; Переходим к следующему символу
               jmp @@for_start                      ; Повторяем цикл

@@end_for:
               pop bp
               ret                                  ; Возвращаемся из функции
elf_hash       endp

;=====================================================================================================
;                                    CONSTANTS
;=====================================================================================================
invitation  db 'Enter your password: $' 
success_msg db 'Success :)', '$'        
user_buffer db 6 dup(0)                  
password    db 'hello', 0           ; TODO как-то спрятать пароль       
fail_msg    db 'Fail', '$'              
true_hash   dw 0                        

;-----------------------------------------------------------------------

end start